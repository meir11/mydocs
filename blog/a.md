---
title : first post
tags : ['javaScript']

---
- [x] פונקציה בנאית [object constructor function]
- [ ] more..
- [ ] and more

## פונקציה בנאית [object constructor function]
באמצעות פונקציה בנאית ניתן ליצור אובייקטים חדשים עם אותו מפתחות עם ערכים שונים בקלות [מקובל שהאות הראשונה גדולה]
```js 
function Myobject(firstName,lastName) {
this.firstName=firstName
this.lastName=lastName
}
let myname = new Myobject('משה','כהן')
```
זה בעצם פונקציה שיוצרת `this = {}` ומאלסת את האוביקט עם הנתנונים ומחזירה אותו

זה כמו שנכתוב
```js
function Myobject(firstName,lastName) {
  return {firstName,lastName}
}
```

 בניגוד לאובייקט רגיל שאפשר לגשת מחוץ לאובייקט ולהוסיף עוד מפתחות וערכים חדשים, בפונקציה בנאית ניתן להוסיף רק בפונקציה עצמה אך ניתן לגשת מבחוץ ע"י prototype לדוגמה :   myobject.prototype.age=34 כיון שכל אובייקטים וכל שאר סוגי המידע שהם בעצם גם אובייקטים יורשים מאוביקט האב Object.prototype
ירושה
אובייקט יכול לרשת מאובייקט אחר

לכל אובייקט יש [[prototype]] ממנו הוא יורש את הדברים מעבר לאובייקט עצמו
בברירת מחדל הוא יורש מ Object.prototype שזה בעצם כל השיטות המובנות של j.s עצמה.
לדוגמה ()obj.toString השיטה toString למרות שלא כתובה בפועל באובייקט הנוכחי הוא מגיע לprototype שלו שזה בעצם Object.prototype ושם הוא נמצא
וכך בעצם כל הסוגי מידע כמו מחרוזת או מספר וכדו' יש להם את prototype שלהם שמגיעים מהשפה. לדוגמה למערך יש את השיטה join שהיא מגיעה מ Array.prototype.
ניתן להגדיר שהאובייקט יורש מאובייקט אחר (והוא גם יורש מObject.prototype) כמובן שאפשר שזה יהיה גם שרשור שלם.
ולכן אם אין באובייקט הנוכחי את המאפיין או השיטה הוא יחפש לראות אם יש במוריש ואם הוא לא מוצא הוא ילך עוד אחורה עד Object.prototype עצמו
חשוב להדגיש שכל אובייקט יכול לרשת רק ממקום אחד בלבד.

השיטה הפשוטה והישנה היא להגיע לזה הוא ע"י המאפיין __proto__ של האובייקט, לדוגמה obj1.__proto__ = obj2  שזה אומר שobj1 יורש מobj2 ולכן אם ניגש ל obj1 כדי לקבל מאפיין או שיטה מסוימת אם אין בנוכחי הוא יקח מobj2
__proto__ ה prototype חייב להיות דווקא אובייקט או null
בפונקציה בנאית אפשר להגדיר מבחוץ מאפיין prototype שבו לכתוב ממי הוא יורש
שיטה עדכנית יותר הוא ע"י Object.create הוא מכיל שתי פרמטרים הראשון זה האובייקט והשני (לא חובה) הוא המאפיינים ושיטות של האובייקט הנוכחי לדוגמה:
 let obj2 = Object.create(obj1,{...})
ובשיטה  (Object.getPrototypeOf(obj ניתן לקבל מאיפה הוא יורש, בפרמטר נכתוב את האובייקט עצמו שאנו רוצים לבדוק מאיפה הוא יורש 
ובשיטה (Object.setPrototypeOf(obj, proto ניתן לערוך מאיפה הוא יורש
 - השיטה Object.keys וכדו' תמיד מתייחס לאובייקט עצמו ורק ב for.. in הוא לוקח גם את מפתחות המוריש (ניתן לסנן זאת ע"י (obj.hasOwnProperty(key )
- הפונקציות תמיד מגדירים את האובייקט הנוכחי ולא את האבות כי הפונקציה מגדיר את this וthis הוא מתייחס לאוביקט עצמו
- תמיד כתיבה מחדש לערכים מגדיר את הערך באוביקט הנוכחי .המורישים הם לקריאה בלבד
קלאס
מבצע כמו פונקציה בנאית בתחביר אחר
הערכים מוגדרים בתוך הconstructor
תחביר קלאסי
class MyClass {
  // class methods
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}


והנה מפורט יותר:
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// Usage:
let user = new User("John");
user.sayHi();

מה שיש ב constructor רץ מיד כשהאובייקט מופעל ע"י new ושאר המתודות בשעת הקריאה אליהם.

ניתן לעשות קלאס מישני שהוא יורש את תכונות ומתודות האב אך עם דברים יחודיים עבורו. ע"י extends
כברירת מחדל אם לא נציין כלום אלא {} ריקים הוא יהיה בדיוק כמו קלאס האב הן constructor והן שאר המתודות
אך אפשר להוסיף בסוגרים {} מתודות נוספות ועכשיו לקלאס הבן יהיה גם את של האב וגם את שלו
אם בקלאס האב מתשמשים באותו שם מתודה של האב יפעל רק של הבן (כי בקריאה הוא קודם כל הוא מחפש האם יש לבן כזו מתודה
אפשר ליצור מתודה אצל קלאס הבן שתקרא לפונקציה האב (ותעשה אם זה איזה פעולה כלשהו)  ע"י כתיבת super.f כלומר הסופר = עליון קורא לפונקצית האב
אם נגדיר בנאי (constructor) נפרד בקלאס הבן  ניתן להוסיף  (צריך לכתוב הן את של הבן והן את של האב - אם רוצים שיהיה בבנאי)
ולציין אח"כ super(מפתחות האב) לפני this וכו' ואז זה יפעל ויקרא לthis של האב 
